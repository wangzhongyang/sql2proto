package parser

import (
	"fmt"
	"github.com/blastrain/vitess-sqlparser/tidbparser/ast"
	"github.com/blastrain/vitess-sqlparser/tidbparser/dependency/mysql"
	"github.com/blastrain/vitess-sqlparser/tidbparser/dependency/types"
	"github.com/blastrain/vitess-sqlparser/tidbparser/parser"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"text/template"
)

func ParseSql(sql string) ([]*StructInfo, error) {
	stmts, err := parser.New().Parse(sql, "", "")
	if err != nil {
		return nil, err
	}
	structArr := make([]*StructInfo, 0, len(stmts))
	for _, stmt := range stmts {
		stmtTmp, ok := stmt.(*ast.CreateTableStmt)
		if !ok {
			return nil, fmt.Errorf("make create table stmt failed")
		}
		fields := make([]StructInfoField, len(stmtTmp.Cols))
		for filedIndex, fieldItem := range stmtTmp.Cols {
			fields[filedIndex].FieldName = resetFieldName(fieldItem.Name.String())
			fields[filedIndex].FieldType = mysqlToProtoBufType(fieldItem.Tp)
			for _, filedOption := range fieldItem.Options {
				if filedOption.Tp == ast.ColumnOptionComment {
					fields[filedIndex].FieldComment = filedOption.Expr.GetDatum().GetString()
				}
			}
		}
		structArr = append(structArr, &StructInfo{Name: resetTableName(stmtTmp.Table.Name.String()), Fields: fields})
	}

	return structArr, nil
}

// resetTableName a-bb_cc -> ABbCc
func resetTableName(name string) string {
	tmp := strings.Split(strings.Replace(name, "-", "_", -1), "_")
	for k, v := range tmp {
		tmp[k] = strings.ToUpper(v[:1]) + v[1:]
	}
	return strings.Join(tmp, "")
}

// resetFieldName a-bb_cc -> aBbCc
func resetFieldName(name string) string {
	tmp := strings.Split(strings.Replace(name, "-", "_", -1), "_")
	for k, v := range tmp {
		if k == 0 {
			continue
		}
		tmp[k] = strings.ToUpper(v[:1]) + v[1:]
	}
	return strings.Join(tmp, "")
}

func mysqlToProtoBufType(colTp *types.FieldType) (name string) {
	switch colTp.Tp {
	case mysql.TypeTiny, mysql.TypeShort, mysql.TypeInt24, mysql.TypeLong:
		if mysql.HasUnsignedFlag(colTp.Flag) {
			name = "uint"
		} else {
			name = "int"
		}
	case mysql.TypeLonglong:
		name = "int64"
	case mysql.TypeFloat, mysql.TypeDouble, mysql.TypeDecimal, mysql.TypeNewDecimal:
		name = "double"
	case mysql.TypeString, mysql.TypeVarchar, mysql.TypeVarString,
		mysql.TypeBlob, mysql.TypeTinyBlob, mysql.TypeMediumBlob, mysql.TypeLongBlob,
		mysql.TypeTimestamp, mysql.TypeDatetime, mysql.TypeDate:
		name = "string"
	case mysql.TypeJSON:
		name = "string"
	default:
		return "UnSupport"
	}
	return
}

var (
	tmplParseOnce sync.Once
	fileTmpl      *template.Template
)

func Parser(options *Options) error {
	outputFile := filepath.Join(options.OutputDir, "gen.proto")
	f, err := os.OpenFile(outputFile, os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		return fmt.Errorf("create output file failed, err:%s", err.Error())
	}
	defer f.Close()
	initTmpl()
	structArr, err := NewReader(options).GetStructList()
	if err != nil {
		return err
	}
	data := FileInfo{
		FilePath:   options.InputFile,
		GenPath:    options.InputFile,
		DirName:    filepath.Base(options.OutputDir),
		StructList: structArr,
	}
	builder := strings.Builder{}
	if err = fileTmpl.Execute(&builder, data); err != nil {
		return fmt.Errorf("execute file tmpl failed, err:%w", err)
	}
	_, _ = f.WriteString(builder.String())
	return nil
}

func NewReader(options *Options) Reader {
	if options.InputFile != "" {
		return &ReadFromFile{options: options}
	}
	if options.MysqlDsn != "" {
		return &ReadFromMySQL{options: options}
	}
	panic("can't new parser read")
}

func initTmpl() {
	tmplParseOnce.Do(func() {
		var err error
		fileTmpl, err = template.New("goFile").Funcs(addTmplFuncs()).Parse(fileTmplRaw)
		if err != nil {
			panic(err)
		}
	})
}

func addTmplFuncs() map[string]any {
	funcMap := map[string]any{
		"sum": func(a, b int) int {
			return a + b
		},
	}
	return funcMap
}

const fileTmplRaw = ` // Code generated by github.com/wangzhongyang/sql2proto
syntax = "proto3";

package {{.DirName}};

option go_package = "./{{.DirName}}";
{{ range $structIndex, $structInfo := .StructList}}
message {{$structInfo.Name}} {
	{{- range $fieldIndex, $fieldInfo := $structInfo.Fields}}
	{{$fieldInfo.FieldType}} {{$fieldInfo.FieldName}} = {{sum $fieldIndex 1}}; {{if $fieldInfo.FieldComment}}// {{$fieldInfo.FieldComment}}{{end}}
	{{- end}}
}
{{end}}
`
